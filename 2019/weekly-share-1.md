# 知识共享第1期

## 一、Android下的MonkeyTest

### 1、设备连接

```
adb devices
```

> 设备得连接成功，接下来的步骤才有意义

### 2、monkey测试命令

```
adb shell monkey -p appPackage -v 5000 > text.txt
```

### 3、appPackage查询方式

#### 方式一：

```
adb shell 

dumpsys window windows | grep -i current
```

>  该方法下得先在手机中打开我们要查询的App

#### 方式二：

使用 [APK Messenger]( https://pan.baidu.com/s/1QtUXiJq4ktHIoy47W8OSrg) 工具，点击可进行下载，其提取码为: dads 

![](http://pic.yuti.site/doc_APKMessenger.png)

#### 方式三：

很直接，问开发，哈哈哈，问你们自己。。。

### 4、日志信息分析

> text.txt 是将运行过程中的日志保存到text的文档中

* CRASH：程序崩溃
* ANR：程序无响应
* Exception：传说中的小问题




## 二、大小端

大小端问题，指多字节存储在寄存器中的安排问题，由什么引起的？常见于哪些应用场景？如何解决？

### 大小端是什么

**小端（Little-Endian）**：低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。

**大端（Big-Endian）**：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

比如数字 0x 12 34 56 78 在内存中的表示形式为：

- 大端模式：

低地址 -----------------> 高地址
0x12  |  0x34  |  0x56  |  0x78

- 小端模式：

低地址 ------------------> 高地址
0x78  |  0x56  |  0x34  |  0x12

#### 两个例子

- 16bit宽的数0x1234在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：

|内存地址 | 小端模式存放内容 | 大端模式存放内容 |
| --- | --- | --- |
|0x4000 | 0x34 | 0x12 |
|0x4001 | 0x12 | 0x34 |

- 32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：

|内存地址 | 小端模式存放内容 | 大端模式存放内容 |
| --- | --- | --- |
|0x4000 | 0x78 | 0x12 |
|0x4001 | 0x56 | 0x34 |
|0x4002 | 0x34 | 0x56 |
|0x4003 | 0x12 | 0x78 |


#### 优劣势

大端小端没有谁优谁劣，各自优势便是对方劣势：

- 小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。
- 大端模式 ：符号位的判定固定为第一个字节，容易判断正负。


### 引起原因

在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

### 常见场景及解决方法

很多时候，字节序的工作已由编译器完成了，但是在一些小的细节上，仍然需要去仔细揣摩考虑，尤其是在以太网通讯、MODBUS通讯、软件移植性方面。

项目开发中，手机蓝牙和STM8单片机蓝牙通信，手机为armv7a架构存储模式为大端，STM8为小端模式，为了单片机端处理方便，手机App端将数据处理成小端数组：

```
for (int i = 0; i < code.length; i += 4) {
    c = code[i];
    code[i] = code[i + 3];
    code[i + 3] = c;
    c = code[i + 1];
    code[i + 1] = code[i + 2];
    code[i + 2] = c;
}

```



### 参考


[https://blog.csdn.net/ce123_zhouwei/article/details/6971544](https://blog.csdn.net/ce123_zhouwei/article/details/6971544)